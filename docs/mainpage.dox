/*! \mainpage This is the Practical Approximation Algorithms library. 
 
  \section Introduction
    The PAAl is a header-only, generic library consisting of approximation algorithms, 
    data structures and several complete solution for the various optimization problems.
    The PAAl is implemented taking advantage of the new features of C++ introduced in the c++0x standard,
    which in many cases simplify greatly creation of generic code.
 
  \section Installation
   There is no need to install anything because the PAAl is header only. 
   All you have to do is to download the library and include appropriate headers.
   Only, if you use linear programming you must link your executable against glpk.

   If you'd like to alter the library, we encourage you to compile the unit test.

  \section get_repo Download
    In order to download repository please run the following command:
    
    <B>    git clone http://siekiera.mimuw.edu.pl:8082/paal </B>

  \section Contents
    The library consists of several sublibraries
    <ul> 
    <li> Algorithms
        <ul>
        <li>\ref local_search
            <ul>
            <li>\ref twoopt 
            <li>\ref fl 
            <li>\ref kmedian
            <li>\ref cfl
            </ul>
        <li> Iterative Rounding
            <ul>
            <li>\ref ta
            </ul>
        <li> Greedy
            <ul>
            <li> \ref shortestsuperstring
            <li> \ref sjoipm
            </ul>
        <li> Miscellaneous
            <ul>
            <li>\ref stein
            </ul>
        </ul>
    <li> Concepts
        <ul>
        <li>\ref metric
        <li>\ref cycle
        <li>\ref voronoi
        </ul>
    <li> Data Structures
        <ul>
        <li>\ref paal::data_structures::GraphMetric
        <li>\ref paal::data_structures::ArrayMetric
        <li>\ref paal::data_structures::SimpleCycle
        <li>\ref paal::data_structures::SplayCycle
        <li>\ref paal::data_structures::ObjectWithCopy
        <li>\ref paal::data_structures::FacilityLocationSolution
        <li>\ref paal::data_structures::Voronoi
        <li>\ref paal::data_structures::CapacitatedVoronoi
        <li>\ref paal::data_structures::SubsetsIterator
        <li>\ref paal::data_structures::VertexToEdgeIterator
        <li>\ref paal::data_structures::BiMap
        </ul>
    </ul>

  \section general_design General Design  
   
  The algorithms are written as functions:
  <pre>
      algorithm(ProblemDescription)
  </pre>
  Very often algorithms can be customized or extended, as they support many different arguments. These arguments are 
  usually wrapped using Components class (see \ref comps), which allows to specify named arguments. In such 
  a case the algorithms is called as follows:
  <pre>
      algorithm(ProblemDescription, Components)
  </pre>

  Generally the library is divided into the following three layers: 
  <pre>
   ___________________________________________________________________________________________________
  
      ALGORITHMS  - e. g., LocalSearch. The algorithms are written in very generic way by 
      delegating the specific tasks to the algorithm helpers.
  ___________________________________________________________________________________________________
  
      ALGORITHMS COMPONENTS - e. g., GetNeighborhood or Commit in local search.
      This are the bricks that directly manipulate the specific data-structure concepts.
  ___________________________________________________________________________________________________
  
      DATA_STRUCTURES - The data-structures used by algorithm helpers. 
      Our data-structures introduce usefull and interesting higher level concepts, e.g., Metric or Cycle.
  ___________________________________________________________________________________________________
  
  </pre>
  <br>
  For each solution concept our library is delivering default implementations of components from each layer. <br>
  The strength of this design is that the user is allowed to change components from each layer freelly. <br><br>
  
  For example the user can easily swap the implementation of the GetNeighborhood to provide his own way of searching the neighborhood
  in local search. <br>
  Also note that the same algorithm helpers that are used by local search can be used to produced the simulated annealing algorithm. <br>
  Similarly, if the user wants to swap the metric implementation to use specific properties of his topology, this is not a problem at all! <br>
  
 \section Platforms
 Currently the library compiles on the gcc 4.7.3. and clang 3.2. Unfortunately, the library does not 
 compile on the newest Microsoft Visual Studio 2013 due to its poor support of c++0x.

//  \section  Testing
//TODO
 
*/
