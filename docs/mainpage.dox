/*! \mainpage This is the Practical Approximation Algorithms Library.
  \image html LOGO-ERC.jpg
  \image html FP7-ide-RGB.jpg

<!-- Not very nice solution...-->
  \n   \n   \n   \n   \n

  \section Introduction

   The PAAL is an open source, a header-only, generic library consisting of
   approximation algorithms, data structures and several complete solutions
   for the various optimization problems.  The PAAL is implemented taking
   advantage of the new features of C++ introduced in the C++14 standard,
   which in many cases simplify greatly creation of generic code.

  \section Installation
   There is no need to install anything because the PAAL is header only.
   All you have to do is download the library and include appropriate headers.
   Only, if you use linear programming you must link your executable against glpk.

   If you'd like to alter the library, we encourage you to compile the unit tests.

  \section get_repo Download
    In order to download repository please run the following command:

    <B>    git clone -\-recursive http://siekiera.mimuw.edu.pl:8082/paal </B>

  \section Contents
    The library consists of several sublibraries
    <ul>
    <li> Algorithms
        <ul>
        <li>\ref local_search_page
            <ul>
            <li>\ref twoopt
            <li>\ref fl
            <li>\ref kmedian
            <li>\ref cfl
            </ul>
        <li>\ref iterative_rounding
            <ul>
            <li>\ref bdmst
            <li>\ref gen_ass
            <li>\ref steiner_network
            <li>\ref tree_aug
            <li>\ref stein_1_39
            </ul>
        <li> Greedy
            <ul>
            <li> \ref budgeted_maximum_coverage
            <li> \ref maximum_coverage
            <li> \ref kcenter
            <li> \ref kcut
            <li> \ref knapsack_greedy
            <li> \ref shortestsuperstring
            <li> \ref scheduling_jobs
            <li> \ref sjoipm
            <li> \ref sjwdoasm
            <li> \ref stein_tree_greedy
            <li> \ref w_set_cover
            </ul>
        <li> Dynamic
            <ul>
            <li> \ref knapsack_dynamic
            <li> \ref knapsack_fptas
            </ul>
        <li> Exact
            <ul>
            <li>\ref stein_dreyfus
            </ul>
        <li>\ref linear_programming
            <ul>
            <li>\ref multiway_cut
            </ul>
        <li>\ref combinatorial_auctions
            <ul>
            <li> \ref winner_determination_in_MUCA
            <li> \ref fractional_winner_determination_in_MUCA
            </ul>
       <li> Regression
            <ul>
            <li>\ref lsh_nn_regression
            </ul>
        <li> Miscellaneous
            <ul>
            <li>\ref stein_zel
            </ul>
        <li> Clustering
            <ul>
            <li> \ref k_means_clustering_engine
            <li> \ref k_means_clustering
            </ul>
        </ul>
    <li> Concepts
        <ul>
        <li>\ref metric
        <li>\ref cycle
        <li>\ref voronoi
        </ul>
    <li> Data Structures
        <ul>
        <li>\ref comps
        <li>\ref do_vv_2kminus1
        <li>\ref paal::data_structures::stack
        <li>\ref paal::data_structures::graph_metric
        <li>\ref paal::data_structures::array_metric
        <li>\ref paal::data_structures::euclidean_metric
        <li>\ref paal::data_structures::simple_cycle
        <li>\ref paal::data_structures::splay_cycle
        <li>\ref paal::data_structures::object_with_copy
        <li>\ref paal::data_structures::facility_location_solution
        <li>\ref paal::data_structures::voronoi
        <li>\ref paal::data_structures::capacitated_voronoi
        <li>\ref paal::data_structures::subsets_iterator
        <li>\ref paal::data_structures::vertex_to_edge_iterator
        <li>\ref paal::data_structures::bimap

        </ul>
    </ul>

  \section general_design General Design

  The algorithms are written as template functions in STL-style.  The major
  change is, that we support ranges instead of iterators.  Usually algorithms
  can be customized or extended, as they support many different arguments.
  Besides, the algorithms, the library contains many useful data-structures.
  Our data structures introduce useful and interesting higher level concepts,
  e.g., Metric or Cycle.


  Besides standalone algorithms, the library contains frameworks which supports
  solving general optimization methods like local search or iterative rounding.
 The functional arguments of these frameworks are usually wrapped
 using Components class (see \ref comps), which allows to specify named arguments.
 In such case the algorithm is called as follows:
 <pre>
    algorithm(ProblemDescription, Components)
 </pre>
 For each concept our library delivers the default implementations of components. <br>
 Of course the user is allowed to replace each component. <br>

Consider for example the local search framework, where the user can can easily
swap the implementation of the GetMoves procedure to provide his own way of
searching the neighborhood.  <br> Also note that the same components, that are
used by local search can be used in the simulated annealing algorithm. <br>
Similarly, if the user wants to swap the metric implementation to use specific
properties of his topology, this is not a problem at all! <br>

 \section Platforms
 Currently the library compiles on the gcc 4.8.1 and clang 3.5. Unfortunately, the library does not
 compile on the Microsoft Visual Studio 2013 due to its poor support of C++14.

 \section License

 The library is released under
 <a href="http://www.boost.org/LICENSE_1_0.txt"> Boost Software License</a>,
 which encourages both commercial and
 non-commercial use.

 \section Contact
 In case of any questions / suggestions / pull requests
 / contribution please contact Piotr Wygocki (wygos at mimuw.edu.pl).

 */
