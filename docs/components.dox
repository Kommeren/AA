/*! \page comps Components

\section mot Motivation. 

The main motivation for components class is handling default arguments. It often happens that function takes many arguments, but very often only some of them are really needed, the rest has default values. The other motivation is that sometimes we'd  like to keep all the arguments grouped together. This way arguments can be easily moved around.

\subsection mot_exmpl Motivating example
Assume that we'd like to write a function which takes three functors Init, Start and Stop. We are going to introduce the interface using the components class.


<b> Very basic usage: </b>

As library developer introduce a interface

<pre>
    template \<typename DoStuffComponents\>
    void do_stuff(DoStuffComponents comps);
</pre>

We introduce the names of the needed components 

<pre>
    struct Init;
    struct Start;
    struct Stop;
</pre>

And define appropriate components class

<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
</pre>


Later on user can run the function
<pre>
    DoStuffComponents<MyInitImpl, MyStartImpl, MyStopImpl> doStuffComponents;
    do_stuff(doStuffComponents);
</pre>
Here we assume that all the implementations have the default constructor, this is not mandatory. There are different ways of initializing components(see section:\ref const_comp for more details).
    
How to get the parameters back from DoStuffComponents:
<pre>
    doStuffComponents.get<Init>(); //getting Init component

    MyInitImpl anotherImplementation(42);
    doStuffComponents.set<Init>(anotherImplementation); //setting Init component

    doStuffComponents.call<Start>("hello world"); // you can directly call component if it is a functor
</pre>


<b> How to provide default parameter: </b>

You can define DoStuffComponents as follows
<pre>
    template <typename... Args>
    using DoStuffComponents = Components\<Init, NameWithDefault\<Start, DefaultStart\>, NameWithDefault\<Stop, DefaultStop\>\>::type\<Args...\>;
</pre>

Later on user can construct the DoStuffComponents as follows
<pre>
    DoStuffComponents<MyInitImpl> doStuffComponents1;
    DoStuffComponents<MyInitImpl, MyStartImpl> doStuffComponents2;
    DoStuffComponents<MyInitImpl, MyStartImpl, MyStopImpl> doStuffComponents3;
</pre>

This is the main motivation but the library consists of much more handy ways of manipulating the Components.

\section def_comp Defining Components 
The type of the component can be any type including references. Default parameters can be specified for any number of last components.
One can define components using template aliasing (preferred)
<pre>
    //inside library:
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;

    //user:
    DoStuffComponents<MyInitImpl, MyStartImpl, MyStopImpl> doStuffComponents;

</pre>
This can be done without template aliasing
<pre>
    //inside library:
    typedef Components<Init, Start, Stop> DoStuffComponents;

    //user:
    DoStuffComponents::type<MyInitImpl, MyStartImpl, MyStopImpl> doStuffComponents;
</pre>

\section const_comp Constructing Components
There are several ways of contructing components:
<ul>
<li> One can provide any number of arguments. The kth argument has to be convertible kth component.
<pre>
    //inside library:
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;

    //user:
    typedef DoStuffComponents<double, int, int> MyDoStuffComponents;

    MyDoStuffComponents doStuffComponents;
    MyDoStuffComponents doStuffComponents(1,2);
    int a;
    MyDoStuffComponents doStuffComponents(a);
</pre>
<li> One can provide any object and a CopyTag. This tag indicates, that passed object has  get<Name> member functions for some Names.
<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
    typedef DoStuffComponents<int, int, int> Big;
    
    template <typename... Args>
    using SmallDoStuffComponents = Components<Start, Stop>::type<Args...>;
    typedef SmallDoStuffComponents<int, int> Small;

    Small small(1,2);
    Big big(small, CopyTag());

    Small small2(big, CopyTag());
</pre>

<li> One can make object providing some arguments by name.

<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
    typedef DoStuffComponents<int, int, int> MyDoStuffComps;

    auto m = MyDoStuffComps::make<Init, Stop>(7, 2); // The start component has default int value (actually as build in it might be uninitialized);
    
</pre>
<li> The user does not have to provide any type at all.
<pre>
    typedef Components<Init, Start, Stop> DoStuffComponents;
    
    int a;
    auto myComps = DoStuffComponents::make_components(1, a, std::ref(a));
</pre>
If the deduced type should be reference, the std::ref wraper should be used.

</ul>
The important thing is that components do not have to be default constructible unless it is acctually default constructed.

\section repl_comps Replacing Components
There is a way to replace component for given components.  

<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
    typedef DoStuffComponents<int, int, int> SomeDoStuffComps;

    typedef ReplacedType<Start, double, SomeDoStuffComps>::type Replaced; // Start type is changed from int to double

    SomeDoStuffComps comps;
    double d(5);
    Replaced replaced = replace<Start>(d, comps); //replacing component
</pre> 

\section iterot Iterating Over Components class (TODO)



*/
