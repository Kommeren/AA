/*! \page comps Components

\section mot Motivation. 

The \a Components class is boost.fusion.map-like class with constant set of keys (names) and support for default values for given key. 
This class meets requirements for specific design of template function. The underlined function instead of taking several arguments takes one \a Components class which represents these arguments. 

This way, argument can be easily replaced. One can implement many versions for each of the arguments and later on these versions can be combined into one \a Components object. On the other hand when the arguments depends on each other they can  be composed into one \a Components class which binds them together into one structure.  
In this implementation one can support several sets of default arguments and permits the function user to easily create new set of defaults arguments. It often happens that a function takes many arguments, but only some of them are really needed, the rest having default values. The other motivation is that sometimes one would like to keep all the arguments grouped together. 
This way arguments can be easily moved around. Another advantage of this design is that we can keep many different configurations of default arguments. An instance of the \a Components class represents one configuration of default arguments. 

\subsection mot_exmpl Motivating example
Assume that we'd like to write a function which takes three functors: Init, Start and Stop. 
We are going to introduce the interface using the \a Components class.


<b> Very basic usage: </b>

As a library developer (or a function provider) we introduce the following interface

<pre>
    template \<typename DoStuffComponents\>
    void do_stuff(DoStuffComponents comps);
</pre>

we introduce the names of the needed components 

<pre>
    struct Init;
    struct Start;
    struct Stop;
</pre>

and specify the  appropriate \a Components class

<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
</pre>


User must implement  InitImpl, StartImpl, StopImpl functors. 
Then the function can ran as follows
<pre>
    DoStuffComponents<InitImpl, StartImpl, StopImpl> doStuffComponents;
    do_stuff(doStuffComponents);
</pre>
Here we assume that all the implementations have default constructors, however this is not mandatory. There are different ways of initializing components(see section:\ref const_comp for more details).
    
How to get the parameters back from DoStuffComponents:
<pre>
    doStuffComponents.get<Init>(); //getting Init component

    InitImpl anotherImplementation(42);
    doStuffComponents.set<Init>(anotherImplementation); //setting Init component

    doStuffComponents.call<Start>("hello world"); // you can directly call a component if it is a functor
</pre>


<b> How to provide default parameters: </b>

You can define \a DoStuffComponents as follows
<pre>
    template <typename... Args>
    using DoStuffComponents = Components\<Init, NameWithDefault\<Start, DefaultStart\>, NameWithDefault\<Stop, DefaultStop\>\>::type\<Args...\>;
</pre>

Later on a user can construct the \a DoStuffComponents as follows
<pre>
    DoStuffComponents<InitImpl> doStuffComponents1;
    DoStuffComponents<InitImpl, StartImpl> doStuffComponents2;
    DoStuffComponents<InitImpl, StartImpl, StopImpl> doStuffComponents3;
</pre>

This is the main motivation but the library consists of much more handy ways of manipulating the \a Components.

\section def_comp Defining Components 
The type of the component can be any type including references. Default parameters can be specified for any number of last components.
One can define components using template aliasing (preferred)
<pre>
    //inside library:
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;

    //user:
    DoStuffComponents<InitImpl, BeginImpl, StopImpl> doStuffComponents;

</pre>
This can also be done without template aliasing
<pre>
    //inside library:
    typedef Components<Init, Start, Stop> DoStuffComponents;

    //user:
    DoStuffComponents::type<InitImpl, BeginImpl, StopImpl> doStuffComponents;
</pre>

\section const_comp Constructing Components
There are several ways of constructing components:
<ul>
<li> One can provide any number of arguments. The kth argument has to be convertible to the kth component.
<pre>
    //inside library:
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;

    //user:
    typedef DoStuffComponents<double, int, int> MyDoStuffComponents;

    MyDoStuffComponents doStuffComponents;
    MyDoStuffComponents doStuffComponents(1,2);
    int a;
    MyDoStuffComponents doStuffComponents(a);
</pre>
<li> One can provide any object and a CopyTag. This tag indicates, that the passed object has  get<Name> member functions for some Names.
<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
    typedef DoStuffComponents<int, int, int> Big;
    
    template <typename... Args>
    using SmallDoStuffComponents = Components<Start, Stop>::type<Args...>;
    typedef SmallDoStuffComponents<int, int> Small;

    Small small(1,2);
    Big big(small, CopyTag());

    Small small2(big, CopyTag());
</pre>

<li> One can make an object providing some arguments by name.

<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
    typedef DoStuffComponents<int, int, int> MyDoStuffComps;

    auto m = MyDoStuffComps::make<Init, Stop>(7, 2); // The start component has default int value (actually as build in it might be uninitialized);
    
</pre>
<li> The user does not have to provide any type at all.
<pre>
    typedef Components<Init, Start, Stop> DoStuffComponents;
    
    int a;
    auto myComps = DoStuffComponents::make_components(1, a, std::ref(a));
</pre>
If the deduced type should be a reference, the std::ref wraper should be used.

</ul>
The important thing is that the components do not have to be default constructible unless it is acctually default constructed.

\section repl_comps Replacing Components
There is a way to replace any component of a given \a Components instance.  

<pre>
    template <typename... Args>
    using DoStuffComponents = Components<Init, Start, Stop>::type<Args...>;
    typedef DoStuffComponents<int, int, int> SomeDoStuffComps;

    typedef ReplacedType<Start, double, SomeDoStuffComps>::type Replaced; // Start type is changed from int to double

    SomeDoStuffComps comps;
    double d(5);
    Replaced replaced = replace<Start>(d, comps); //replacing component
</pre> 

\section comp_to_other_libs Comparison to other libraries
<ul>
    <li> Boost.Parameter

        Main differences between boost.parameter and \a Components classes:
        <ul>
        <li> The \a Components class supports different sets of default arguments. This can be done very easily also by function user. 
        <li> The \a Components class is written in pure C++ (no macros).
        <li> The \a Components supports default arguments only when they can be default constructed (boost.parameter is much more flexible here). 
        </ul>
        The \a Components class is not designed to replace boost.parameter but in many cases (e.g. when the given arguments are functors or when the given arguments can depend on each other) 
        it might be a more natural design.

    <li> Boost.Fusion

        Although the idea of the \a Components is very similar to boost.fusion.map, the \a Components gives some functionalities that are not offered by boost.fusion.map.
        The example is different initialization methods (see section:\ref const_comp for more details).

</ul>

\section supp_com Supported Compilers
<ul>
<li> clang 3.2
<li> g++ 4.7.2
</ul>
Msvc is not supported due to lack of template aliasing. 

\section iterot Iterating Over Components class (TODO)



*/
