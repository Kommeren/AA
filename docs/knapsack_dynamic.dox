/*! \page knapsack_dynamic Knapsack Dynamic

\section def Problem definition.
<!--
TODO this is not consistant
-->
\verbinclude knapsack_definition.dox

\section solkd Solution
Both variants of Knapsack are solved using the dynamic approach. The dynamic table can be index both by size and value. 
The algorithm chooses better of these two.
In case of capacity indexed table, we construct a table of size \f$[0-capacity]\f$. Each cell of the table contains information about the best value for this size of knapsack.
The value indexed table case is analogous.
In each round we update the table adding new objects from object set. 
In the Knapsack 0/1, the divide and conquer approach is used to retrieve the set of objects in the optimal solution.
 Knapsack example: 
\snippet knapsack_example.cpp Knapsack Example
 
  complete example is knapsack_example.cpp
 
Knapsack 0/1 example: 
\snippet knapsack_0_1_example.cpp Knapsack Example
 
  complete example is knapsack_0_1_example.cpp

Knapsack 0/1 (does not compute items in knapsack) example: 
\snippet knapsack_0_1_example.cpp Knapsack Example
 
  complete example is knapsack_0_1_no_output_example.cpp

The library provides function paal::knapsack function which solves standard knapsack problem. And two versions of knapsack 0/1 problem : knapsack_0_1 and knapsack_0_1_no_output . One solves the Knapsack 0/1 with retrieving solution and one omitting this procedure. Although retrieving solution does not increase the complexity, it is costly procedure.

\subsection Complexity
The algorithms works in \f$O(min(Capacity, Opt) * NumberOfObjects)\f$ and in \f$O(min(Capacity, Opt))\f$ memory, where Opt is the optimal value of the knapsack.

\subsection References

The algorithm is described in the \cite conf/asap/NibbelinkRM07

\subsection kanpsack_greedy_sa See Also
<ul>
<li> \ref knapsack_fptas
<li> \ref knapsack_greedy
</ul>

*/
