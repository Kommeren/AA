/*! \page local_search Local Search
Index:
<ul>
    <li> \ref Preliminaries - containing preliminaries to Local Search and our interpretation of it.
    <li> \ref local_search_interface - containing c++ interfaces of Local Search classes.
    <ul>
    <li> \ref local_search_single
    <li> \ref local_search_multi
    <li> \ref custom_components
    </ul>
</ul>


\section Preliminaries 
Let us consider maximization problem : <br><br>

max f(x) over x in X. <br><br>

A well known heuristic for solving problem formulated in such a way is the local search(LS). <br>
Assume that we have feasible solution x' in X. <br>
The LS algorithm searches the neighborhood N(x') of x' and tries to localize the better solution x'' with f(x'') > f(x'). <br>
If the better solution is found we set x' equal x'' and rerun previous step. <br>
If better solution couldn't be found we finish the search with resulting local optimum x*. <br><br>

This algorithm can be repeated and the best local optimum is presented. <br><br>

Let us write the pseudo code for this operation:  <br><br>

<pre>
 local_search() 
 {
     x -> random_solution(X)  
     for_each(Move u in N(x)) 
     { 
         if(gain(apply u on x) > 0) 
         {
             x -> apply u on x 
         }
     }
     return x
 }
</pre>

Note that we are working on moves (not on the full solution). This idea is going to be used in the c++ code. <br> 
The reason of this is the fact that usually the moves are much lighter than the full solutions. <br>
<br>
Note that in many cases, eg. k-local search or facility location, our solution is  the collection of the elements.<br>
In many cases for such solutions we search the neighborhood of each solution element and try to improve it by changing some part of the solution near the chosen solution element. <br>
<br>
In this cases it is more convenient to proceed in the following way:<br>

<pre>
 local_search() 
 {
     x -> random_solution(X) 
     for_each(Element e of x)
     {
      for_each(Move u in N(e)) 
      { 
         if(gain(apply u on x) > 0) 
         {
             x -> apply u on x 
         }
      }
     }
     return x
 }
</pre>
<br>
We find this algorithm schema  extremely useful in our implementation! <br>
We will refer to this schema as LocalSearchMultiSolution. <br>
Also if necessary we will refer to the "normal" LS as LocalSearchSingleSolution.

\section local_search_interface  LOCAL SEARCH INTERFACE
Our local search is based on the LocalSearchStep concept. LocalSearchStep is a class which is responsible for one step of the local search. By the one step of the local search we understand one lookup of the neighborhood. The lookup is finished by one move if the better solution is found.
So the LocalSearchStep archetype is of the form:
<pre>
   class LocalSearchStepArchetype {
       //perform one step of local search
       bool search();

       //get solution
       Solution & getSolution();
   }
</pre>

The LocalSearchStep is actually the core of the design. In the simplest variant, if we've  got the LocalSearchStep, all we have to do is to run search as long as it's  returning true.
In the more general case one can check some additional stop condition and perform some operations between the local search steps. In order to make it possible we introduce two additional concepts:
<pre>
    class PostSearchActionArchetype {
        void operator()(Solution &);
    }
</pre>
The PostSearchAction functor is invoked after each successful search step.
<pre>
    class GlobalStopConditionArchetype {
        bool operator()(Solution &);
    }
</pre>
The GlobalStopCondition is checked after each successful search step.

Now we introduce the search function interface:
<pre>
template <typename LocalSearchStep, 
          typename PostSearchAction = utils::DoNothingFunctor,
          typename GlobalStopCondition = utils::ReturnFalseFunctor>
bool search(LocalSearchStep & lss, 
            PostSearchAction psa = utils::DoNothingFunctor(),
            GlobalStopCondition gsc = utils::ReturnFalseFunctor());
</pre>

\subsection local_search_single LOCAL SEARCH SINGLE SOLUTION

In order to present the local search step interface we need to introduce several concepts.<br>
Note that <i>Solution</i> is the solution type and <i>Move</i> is the type of single move. <br>
<i>MoveIteratorsRange</i> is assumed to be std::pair of iterators, pointing to the begin and end of the moves collection. <br><br>

Concepts:
<ol>
    <li> <i>GetMoves</i>  is a concept class responsible for getting the neighborhood of the current solution  
    <pre>
    GetMovesArchetype {
        MoveIteratorsRange operator()(const Solution & s)
    }
    </li>
    </pre>
    <li> <i>Gain</i> is a concept class responsible for checking if the specific move element improve the solution.
    <pre>
    GainArchetype {
        int operator()(const Solution & s, const Move & move);
    }
    </pre>
    </li>
    <li> <i>Commit</i> is a concept class responsible for updating the solution with the Move.
    <pre>
    CommitArchetype {
        int operator()(Solution & s, const Move & move);
    }
    </pre>
    
    </li>
    <li> <i>StopCondition</i> is a concept class responsible for stop condition.
    <pre>
    StopConditionArchetype {
        bool operator()(const Solution & s, const Move & move);
    }
    </pre>
    </li>
    <li> <i>SearchComponents</i> All of the previous concepts are grouped together into one class using \ref comps class with four components: GetMoves, Gain, Commit, StopCondition.
    </li>
</ol>

Now we can introduce the paal::local_search::LocalSearchStep interface. Note that you can pass arbitrary number of SearchComponents to one local search. If your problem have many different Move types it might be usefull to provide SearchComponents for each type of Move.

\subsubsection Example
complete example: local_search_example.cpp

In this example we are going to maximize function -x^2 + 12x -27 for integral x. 
In this problem solution is just a integral and move is also a number which denotes the shift on the solution.
So new potential solution is just old solution plus the move.
We start with defining search components, that is:
<ol>
<li> GetMoves functor </li>
<li> Gain functor </li>
<li> Commit functor </li>
</ol>
Note that we don't define StopCondition i.e. we're using default TrivialStopCondition.

\snippet local_search_example.cpp Local Search Components Example

After we've defined components we run LS.

\snippet local_search_example.cpp Local Search Example

\subsection local_search_multi LOCAL SEARCH MULTI SOLUTION 

The interface and concepts of the  LocalSearchMultiSolution are very similar to the LocalSearchSingleSolution ones.<br>

<br>
Note that <i>SolutionElement</i> is the type of the specific element of the solution. <br>
<i>SolutionElementIterator</i> is assumed to be the type of iterators over solution. <br><br>

Concepts:
<ol>
    <li> <i>MultiSolution</i>  is a concept class representing the  solution  
    <pre>
    MultiSolutionArchetype  begin();
        SolutionElementIterator end();
        InnerSolution get(); // OPTIONAL, very often solution concept is just adapter containing real solution, 
                             // The inner solution type is InnerSolution
                             // If this member function is provided, the LocalSearchStep getSolution() returns InnerSolution.
    }
    </pre>
    <li> <i>MultiGetMoves</i>  is a concept class responsible for getting the neighborhood of the current solution  
    <pre>
    MultiGetMovesArchetype {
        MoveIteratorsRange operator()(const Solution & s, const SolutionElement &)
    }
    </pre>
    <li> <i>MultiGain</i> is a concept class responsible for checking if the specific move element improve the solution.
    <pre>
    MultiGainArchetype {
        int operator()(const Solution & s, const SolutionElement &, const Move & move);
    }
    </pre>
    <li> <i>MultiCommit</i> is a concept class responsible for updating the solution with the Move.
    <pre>
    MultiSolutionUdaterArchetype {
        int operator()(Solution & s, const SolutionElement &, const Move & move);
    }
    </pre>
    
    <li> <i>MultiStopCondition</i> is a concept class responsible for stop condition.
    <pre>
    StopCondition {
        bool operator()(const Solution & s, const SolutionElement & se, const Move & move);
    }
    </pre>
    
    <li> <i>MultiSearchComponents</i> All of the previous concepts are grouped together into one class using \ref comps class with four components: GetMoves, Gain, Commit, StopCondition.
    </li>
</ol>

Now we can introduce the paal::local_search::LocalSearchStepMultiSolution interface. Note that you can pass arbitrary number of SearchComponents to one locacl search. If your problem have many different Move types it might be usefull to provide SearchComponents for each type of Move.

\subsubsection Example
complete example: local_search_multi_solution_example.cpp

In this example we are going to maximize function<br> x1*x2 + x2*x3 + x3*x1 -3*x1*x2*x3<br> for  x1, x2, x3 in <0,1> interval.<br> 
In this problem solution is just a float vector, solution element is float and move is also a float which denotes the new value for solution element.
We start with defining search components, that is:
<ol>
<li> GetMoves functor
<li> Gain functor
<li> Commit functor
</ol>
Note that we don't define StopCondition i.e. we're using default TrivialStopCondition.

\snippet local_search_multi_solution_example.cpp Local Search Components Example

After we've defined components we run LS.

\snippet local_search_multi_solution_example.cpp Local Search Example

\section custom_components CUSTOM COMPONENTS

The library provides a number of custom components which might be very helpful.
<ol>
<li> paal::local_search::GainCutSmallImproves
<li> paal::local_search::StopConditionTimeLimit
<li> paal::local_search::StopConditionCountLimit
<li> paal::local_search::ComputeGainWrapper
</ol>
*/



