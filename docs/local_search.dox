/*! \page local_search_page Local Search
Index:
<ul>
    <li> \ref Preliminaries - containing preliminaries to Local Search and our interpretation of it.
    <li> \ref local_search_interface - containing c++ interfaces of Local Search classes.
    <ul>
    <li> \ref local_search
    <li> \ref custom_components
    </ul>
</ul>


\section Preliminaries 
Let us consider maximization problem : <br><br>

max f(x) over x in X. <br><br>

A well known heuristic for solving problem formulated in such a way is the local search(LS). <br>
Assume that we have feasible solution x' in X. <br>
The LS algorithm searches the neighborhood N(x') (the set of posible moves) of x' and tries to localize the better solution x'' with f(x'') > f(x'). <br>
If the better solution is found we set x' equal x'' and rerun previous step. <br>
If better solution couldn't be found we finish the search with resulting local optimum x*. <br><br>

This algorithm can be repeated and the best local optimum is presented. <br><br>

Let us write the pseudo code for this operation:  <br><br>

<pre>
 local_search() 
 {
     x -> random_solution(X)  
     for_each(Move u in N(x)) 
     { 
         if(gain(apply u on x) > 0) 
         {
             x -> apply u on x 
         }
     }
     return x
 }
</pre>

Note that we are working on moves (not on the full solution). This idea is going to be used in the c++ code. <br> 
The reason of this is the fact that usually the moves are much lighter than the full solutions. <br>

\section local_search_interface  LOCAL SEARCH INTERFACE
Our local search is divided into steps. One step of the local search consists on checking possible moves and finding move with positive gain (or the move with the biggest gain in the SteepestSlope strategy). 
In other words, by the one step of the local search we understand one lookup of the neighborhood. 

 In the default variant, we prolong search as long as the last step is producing the move with positive gain.
In the more general case one can check some additional stop condition and perform some operations between the local search steps. In order to make it possible we introduce two additional concepts:
<pre>
    class PostSearchActionArchetype {
        void operator()(Solution &);
    }
</pre>
The PostSearchAction functor is invoked after each successful search step.
<pre>
    class GlobalStopConditionArchetype {
        bool operator()(Solution &);
    }
</pre>
The GlobalStopCondition is checked after each successful search step.

As mentioned before there are two possible strategies in step excecution.
<ul>

<li> We can iterate through  moves until we find the move with positive gain. This strategy is called ChooseFirstBetter and this is this is the default strategy.
<li> We can iterate through all moves and chose one with the largest gain. This strategy is called SteepestSlope.
</ul>

The \ref local_search section introduces complete interface of the local search.

\subsection local_search LOCAL SEARCH INTERFACE 

In order to present the local search step interface we need to introduce several concepts.<br>
Note that <i>Solution</i> is the solution type and <i>Move</i> is the type of single move. <br>
<i>MoveIteratorsRange</i> is assumed to be std::pair of iterators, pointing to the begin and end of the moves collection. <br><br>

Concepts:
<ol>
    <li> <i>GetMoves</i>  is a concept class responsible for getting the neighborhood of the current solution  
    <pre>
    GetMovesArchetype {
        MoveIteratorsRange operator()(const Solution & s)
    }
    </li>
    </pre>
    <li> <i>Gain</i> is a concept class responsible for checking if the specific move element improve the solution.
    <pre>
    GainArchetype {
        int operator()(const Solution & s, const Move & move);
    }
    </pre>
    </li>
    <li> <i>Commit</i> is a concept class responsible for updating the solution with the Move.
    <pre>
    CommitArchetype {
        int operator()(Solution & s, const Move & move);
    }
    </pre>
    
    </li>
    <li> <i>SearchComponents</i> All of the previous concepts are grouped together into one class using \ref comps class with four components: GetMoves, Gain, Commit, StopCondition.
    </li>
</ol>

Now we can introduce the paal::local_search::local_search interface. Note that you can pass arbitrary number of SearchComponents to one local search. If your problem have many different Move types it might be useful to provide SearchComponents for each type of Move.

The simple version of local search:
<pre>
template <typename SearchStrategy = search_strategies::ChooseFirstBetter, 
          typename Solution, 
          typename... Components>
bool local_search_simple(Solution & solution, Components... components);
</pre>


The more sophisticated version of local search:
<pre>
template <typename SearchStrategy = search_strategies::ChooseFirstBetter,
          typename PostSearchAction,
          typename GlobalStopCondition,
          typename Solution,
          typename... Components>
bool local_search(
            Solution & solution,
            PostSearchAction psa,
            GlobalStopCondition gsc,
            Components... components);
</pre>


\subsubsection Example
complete example: local_search_example.cpp

In this example we are going to maximize function -x^2 + 12x -27 for integral x. 
In this problem solution is just a integral and move is also a number which denotes the shift on the solution.
So new potential solution is just old solution plus the move.
We start with defining search components, that is:
<ol>
<li> GetMoves functor </li>
<li> Gain functor </li>
<li> Commit functor </li>
</ol>

\snippet local_search_example.cpp Local Search Components Example

After we've defined components we run LS.

\snippet local_search_example.cpp Local Search Example

\section custom_components CUSTOM COMPONENTS

The library provides a number of custom components which might be very helpful.
<ol>
<li> paal::local_search::GainCutSmallImproves
<li> paal::local_search::StopConditionTimeLimit
<li> paal::local_search::StopConditionCountLimit
<li> paal::local_search::ComputeGainWrapper
<li> paal::local_search::RecordSolutionCommitAdapter
<li> paal::local_search::TabuGainAdaptor
<li> paal::local_search::SimulatedAnnealingGainAdaptor
</ol>

Since library employs the iterators, the following utilities might be helpful 
<ol>
<li> boost::transform_iterator
<li> boost::filter_iterator
<li> boost::function_input_iterator
<li> paal::IteratorWithStopCondition
<li> paal::data_structures::CombineIterator
<li> paal::data_structures::SubsetsIterator
</ol>
*/



