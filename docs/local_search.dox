/*! \page local_search_page Local Search
Index:
<ul>
    <li> \ref Preliminaries - containing preliminaries to Local Search and our interpretation of it.
    <li> \ref local_search_interface - containing c++ interfaces of Local Search classes.
    <ul>
    <li> \ref local_search_single
    <li> \ref local_search_multi
    <li> \ref custom_components
    </ul>
</ul>


\section Preliminaries 
Let us consider maximization problem : <br><br>

max f(x) over x in X. <br><br>

A well known heuristic for solving problem formulated in such a way is the local search(LS). <br>
Assume that we have feasible solution x' in X. <br>
The LS algorithm searches the neighborhood N(x') (the set of posible moves) of x' and tries to localize the better solution x'' with f(x'') > f(x'). <br>
If the better solution is found we set x' equal x'' and rerun previous step. <br>
If better solution couldn't be found we finish the search with resulting local optimum x*. <br><br>

This algorithm can be repeated and the best local optimum is presented. <br><br>

Let us write the pseudo code for this operation:  <br><br>

<pre>
 local_search() 
 {
     x -> random_solution(X)  
     for_each(Move u in N(x)) 
     { 
         if(gain(apply u on x) > 0) 
         {
             x -> apply u on x 
         }
     }
     return x
 }
</pre>

Note that we are working on moves (not on the full solution). This idea is going to be used in the c++ code. <br> 
The reason of this is the fact that usually the moves are much lighter than the full solutions. <br>
<br>
Note that in many cases, eg. k-local search or facility location, our solution is  the collection of the elements.<br>
In many cases for such solutions we search the neighborhood of each solution element and try to improve it by changing some part of the solution near the chosen solution element. <br>
<br>
In this cases it is more convenient to proceed in the following way:<br>

<pre>
 local_search() 
 {
     x -> random_solution(X) 
     for_each(Element e of x)
     {
      for_each(Move u in N(e)) 
      { 
         if(gain(apply u on x) > 0) 
         {
             x -> apply u on x 
         }
      }
     }
     return x
 }
</pre>
<br>
We find this algorithm schema  extremely useful in our implementation! <br>
We will refer to this schema as LocalSearchMultiSolution. <br>
Also if necessary we will refer to the "normal" LS as LocalSearchSingleSolution.

\section local_search_interface  LOCAL SEARCH INTERFACE
Our local search is divided into steps. One step of the local search consists on checking possible moves and finding move with positive gain (or the move with the biggest gain in the SteepestSlope strategy). 
In other words, by the one step of the local search we understand one lookup of the neighborhood. 

 In the default variant, we prolong search as long as the last step is producing the move with positive gain.
In the more general case one can check some additional stop condition and perform some operations between the local search steps. In order to make it possible we introduce two additional concepts:
<pre>
    class PostSearchActionArchetype {
        void operator()(Solution &);
    }
</pre>
The PostSearchAction functor is invoked after each successful search step.
<pre>
    class GlobalStopConditionArchetype {
        bool operator()(Solution &);
    }
</pre>
The GlobalStopCondition is checked after each successful search step.

As mentioned before there are two possible strategies in step excecution.
<ul>

<li> We can iterate through  moves until we find the move with positive gain. This strategy is called ChooseFirstBetter and this is this is the default strategy.
<li> We can iterate through all moves and chose one with the largest gain. This strategy is called SteepestSlope.
</ul>

The \ref local_search_single and  \ref local_search_multi section introduce complete interface of the local search.

\subsection local_search_single LOCAL SEARCH SINGLE SOLUTION

In order to present the local search step interface we need to introduce several concepts.<br>
Note that <i>Solution</i> is the solution type and <i>Move</i> is the type of single move. <br>
<i>MoveIteratorsRange</i> is assumed to be std::pair of iterators, pointing to the begin and end of the moves collection. <br><br>

Concepts:
<ol>
    <li> <i>GetMoves</i>  is a concept class responsible for getting the neighborhood of the current solution  
    <pre>
    GetMovesArchetype {
        MoveIteratorsRange operator()(const Solution & s)
    }
    </li>
    </pre>
    <li> <i>Gain</i> is a concept class responsible for checking if the specific move element improve the solution.
    <pre>
    GainArchetype {
        int operator()(const Solution & s, const Move & move);
    }
    </pre>
    </li>
    <li> <i>Commit</i> is a concept class responsible for updating the solution with the Move.
    <pre>
    CommitArchetype {
        int operator()(Solution & s, const Move & move);
    }
    </pre>
    
    </li>
    <li> <i>SearchComponents</i> All of the previous concepts are grouped together into one class using \ref comps class with four components: GetMoves, Gain, Commit, StopCondition.
    </li>
</ol>

Now we can introduce the paal::local_search::local_search interface. Note that you can pass arbitrary number of SearchComponents to one local search. If your problem have many different Move types it might be useful to provide SearchComponents for each type of Move.

The simple version of local search:
<pre>
template <typename SearchStrategy = search_strategies::ChooseFirstBetter, 
          typename Solution, 
          typename... Components>
bool local_search_simple(Solution & solution, Components... components);
</pre>


The more sophisticated version of local search:
<pre>
template <typename SearchStrategy = search_strategies::ChooseFirstBetter,
          typename PostSearchAction,
          typename GlobalStopCondition,
          typename Solution,
          typename... Components>
bool local_search(
            Solution & solution,
            PostSearchAction psa,
            GlobalStopCondition gsc,
            Components... components);
</pre>


\subsubsection Example
complete example: local_search_example.cpp

In this example we are going to maximize function -x^2 + 12x -27 for integral x. 
In this problem solution is just a integral and move is also a number which denotes the shift on the solution.
So new potential solution is just old solution plus the move.
We start with defining search components, that is:
<ol>
<li> GetMoves functor </li>
<li> Gain functor </li>
<li> Commit functor </li>
</ol>

\snippet local_search_example.cpp Local Search Components Example

After we've defined components we run LS.

\snippet local_search_example.cpp Local Search Example

\subsection local_search_multi LOCAL SEARCH MULTI SOLUTION 

The interface and concepts of the  LocalSearchMultiSolution are very similar to the LocalSearchSingleSolution ones.<br>

<br>
Note that <i>SolutionElement</i> is the type of the specific element of the solution. <br>
<i>SolutionElementIterator</i> is assumed to be the type of iterators over solution. <br><br>

Concepts:
<ol>
    <li> <i>MultiSolution</i>  is a concept class representing the  solution  
    <pre>
    MultiSolutionArchetype {
        SolutionElementIterator begin();
        SolutionElementIterator end();
    }
    </pre>
    <li> <i>MultiGetMoves</i>  is a concept class responsible for getting the neighborhood of the current solution  
    <pre>
    MultiGetMovesArchetype {
        MoveIteratorsRange operator()(const Solution & s, const SolutionElement &)
    }
    </pre>
    <li> <i>MultiGain</i> is a concept class responsible for checking if the specific move element improve the solution.
    <pre>
    MultiGainArchetype {
        int operator()(const Solution & s, const SolutionElement &, const Move & move);
    }
    </pre>
    <li> <i>MultiCommit</i> is a concept class responsible for updating the solution with the Move.
    <pre>
    MultiSolutionUdaterArchetype {
        int operator()(Solution & s, const SolutionElement &, const Move & move);
    }
    </pre>
    
    
    <li> <i>MultiSearchComponents</i> All of the previous concepts are grouped together into one class using \ref comps class with three components: GetMoves, Gain, Commit.
    </li>
</ol>

Now we can introduce the paal::local_search::multi_local_search interface. Note that you can pass arbitrary number of MultiSearchComponents to one local search. If your problem have many different Move types it might be useful to provide SearchComponents for each type of Move.

Simple version:
<pre>
template <typename SearchStrategy = search_strategies::ChooseFirstBetter, 
          typename Solution, 
          typename... Components>
bool local_search_multi_solution_simple(Solution & solution, Components... components);
</pre>

More sophisticated version:

<pre>
template <typename SearchStrategy = search_strategies::ChooseFirstBetter,
          typename PostSearchAction,
          typename GlobalStopCondition,
          typename Solution,
          typename... Components>
bool local_search_multi_solution(
            Solution & solution,
            PostSearchAction psa,
            GlobalStopCondition gsc,
            Components... components);
</pre>


\subsubsection Example
complete example: local_search_multi_solution_example.cpp

In this example we are going to maximize function<br> x1*x2 + x2*x3 + x3*x1 -3*x1*x2*x3<br> for  x1, x2, x3 in <0,1> interval.<br> 
In this problem solution is just a float vector, solution element is float and move is also a float which denotes the new value for solution element.
We start with defining search components, that is:
<ol>
<li> GetMoves functor
<li> Gain functor
<li> Commit functor
</ol>

\snippet local_search_multi_solution_example.cpp Local Search Components Example

After we've defined components we run LS.

\snippet local_search_multi_solution_example.cpp Local Search Example

\section custom_components CUSTOM COMPONENTS

The library provides a number of custom components which might be very helpful.
<ol>
<li> paal::local_search::GainCutSmallImproves
<li> paal::local_search::StopConditionTimeLimit
<li> paal::local_search::StopConditionCountLimit
<li> paal::local_search::ComputeGainWrapper
</ol>

Since library employs the iterators, the following utilities might be helpful 
<ol>
<li> boost::trasform_iterator
<li> boost::filter_iterator
<li> boost::function_input_iterator
<li> paal::IteratorWithStopCondition
</ol>
*/



