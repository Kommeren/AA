//=======================================================================
// Copyright (c) 2014 Andrzej Pacuk
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//=======================================================================
/**
 * @file hash_functions.hpp
 * @brief
 * @author Andrzej Pacuk
 * @version 1.0
 * @date 2014-10-07
 */
#ifndef PAAL_HASH_FUNCTIONS_HPP
#define PAAL_HASH_FUNCTIONS_HPP

#include "paal/utils/type_functions.hpp"

#include <boost/range/algorithm/generate.hpp>
#include <boost/range/numeric.hpp>
#include <boost/range/size.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/vector_expression.hpp>

#include <cassert>
#include <cmath>
#include <cstddef>
#include <random>
#include <utility>

namespace paal {

namespace hash {

/**
 * @brief simple hash function
 */
template <typename IntType = std::size_t>
class projection_hash_function {
    IntType m_chosen_position;

public:
    /**
     * @brief constructor
     *
     * @param chosen_position
     *
     */
    projection_hash_function(IntType chosen_position) :
            m_chosen_position(chosen_position) {
    }

    /**
     * @brief operator()
     *
     * @tparam Range
     * @param range
     *
     * @return
     */
    template <typename Range>
    //TODO change to decltype(auto), when it starts working
    auto operator()(Range &&range) const ->
            range_to_elem_t<decltype(range)> {
        assert(m_chosen_position < boost::size(range));
        return range[m_chosen_position];
    }
};

/**
 * @brief Factory class for projection_hash_function
 */
template <typename RandomEngine = std::default_random_engine,
          typename IntType = std::size_t>
class random_projection_hash_function_generator {
    RandomEngine m_generator;
    typedef std::uniform_int_distribution<IntType> distribution_t;
    distribution_t m_distribution;

    static IntType convert_to_inclusive(IntType upper_bound) {
        assert(upper_bound > 0);
        return upper_bound - 1;
    }

public:
    /**
     * @brief constructor
     *
     * @param range_size
     * @param random_engine
     */
    random_projection_hash_function_generator(IntType range_size,
            RandomEngine random_engine = RandomEngine{}) :
            m_generator(std::move(random_engine)),
            m_distribution(0, convert_to_inclusive(range_size)) {
    }

    /**
     * @brief operator()
     *
     * @return new projection_hash_function
     */
    //TODO change to auto, when it starts working
    projection_hash_function<IntType> operator()() {
        return projection_hash_function<IntType>(m_distribution(m_generator));
    }
};

using hamming_hash_function_generator =
    random_projection_hash_function_generator<>;
using default_hash_function_generator = hamming_hash_function_generator;

/**
 */
/// hash_function for l_p distance for p in range (0,2]
template <typename FloatType = double>
class l_p_hash_function {
public:
    using r_param_t = boost::numeric::ublas::vector<FloatType>;

private:
    r_param_t m_r;
    FloatType m_b;
    FloatType m_w;

public:
    /**
     * @brief constructor
     *
     * @param r r elements has to be generated by p-stable distribution
     * @param b b is a random value from [0, w)
     * @param w w should be much greater than expected points neighborhood
     * radius
     */
    l_p_hash_function(r_param_t r,
                      FloatType b, FloatType w) :
            m_r(std::move(r)), m_b(b), m_w(w) {
    }

    /**
     * @brief operator()
     *
     * @tparam Range
     * @param range Range modeling boost uBLAS VectorExpression concept
     *
     * @return
     */
    template <typename Range>
    auto operator()(Range &&range) const {
        //TODO use concept check with VectorExpressionConcept<Range>,
        //when it works

        assert(boost::size(m_r) == boost::size(range));

        using boost::numeric::ublas::inner_prod;
        auto inner_product = inner_prod(m_r, range);
        return std::floor((m_b + inner_product) / m_w);
    }

};

/**
 * @brief Factory class for l_p_hash_function
 */
template <typename FloatType = double,
          typename RandomEngine = std::default_random_engine,
          typename Distribution = std::normal_distribution<FloatType>>
class l_p_hash_function_generator {
    std::size_t m_range_size;
    FloatType m_w;
    RandomEngine m_generator;
    Distribution m_r_distribution;
    std::uniform_real_distribution<FloatType> m_b_distribution;

public:
    /**
     * @brief constructor
     *
     * @param range_size
     * @param w
     * @param random_engine
     */
    l_p_hash_function_generator(std::size_t range_size,
                                FloatType w,
                                RandomEngine random_engine = RandomEngine{}) :
            m_range_size(range_size),
            m_w(w),
            m_generator(std::move(random_engine)),
            m_b_distribution(FloatType{}, w) {
    }

    /**
     * @brief operator()
     *
     * @return new l_p_hash_function
     */
    l_p_hash_function<FloatType> operator()() {
        typename l_p_hash_function<FloatType>::r_param_t r(m_range_size);
        boost::generate(r, [&]() {
            return m_r_distribution(m_generator);
        });

        FloatType b = m_b_distribution(m_generator);
        return l_p_hash_function<FloatType>(std::move(r), b, m_w);
    }
};

/// Cauchy distribution is 1-stable
template <typename FloatType = double,
          typename RandomEngine = std::default_random_engine>
using l_1_hash_function_generator =
    l_p_hash_function_generator<FloatType, RandomEngine,
                                std::cauchy_distribution<FloatType>>;

/// Gaussian distribution is 2-stable
template <typename FloatType = double,
          typename RandomEngine = std::default_random_engine>
using l_2_hash_function_generator =
    l_p_hash_function_generator<FloatType, RandomEngine>;

} //! hash

} //! paal

#endif // PAAL_HASH_FUNCTIONS_HPP

